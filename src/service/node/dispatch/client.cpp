#include "cocaine/detail/service/node/dispatch/client.hpp"

#include "cocaine/detail/service/node/slave.hpp"

using namespace cocaine;

client_rpc_dispatch_t::client_rpc_dispatch_t(const std::string& name):
    dispatch<incoming_tag>(format("%s/C2W", name)),
    state(state_t::open)
{
    // Uncaught exceptions here will lead to a client disconnection and further dispatch discarding.

    on<protocol::chunk>([&](const std::string& chunk) {
        stream.write(chunk);
    });

    on<protocol::error>([&](int id, const std::string& reason) {
        stream.abort(id, reason);
        finalize();
    });

    on<protocol::choke>([&] {
        stream.close();
        finalize();
    });
}

void
client_rpc_dispatch_t::attach(upstream<outcoming_tag> stream_, callback_type callback_) {
    std::lock_guard<std::mutex> lock(mutex);

    stream.attach(std::move(stream_));

    switch (state) {
    case state_t::open:
        state = state_t::bound;
        callback = callback_;
        break;
    case state_t::closed:
        callback_(ec);
        break;
    default:
        BOOST_ASSERT(false);
    }
}

void
client_rpc_dispatch_t::discard(const std::error_code& ec) const {
    // TODO: Consider something less weird.
    const_cast<client_rpc_dispatch_t*>(this)->discard(ec);
}

void
client_rpc_dispatch_t::discard(const std::error_code& ec) {
    if (ec) {
        this->ec = ec;

        try {
            // TODO: Add category to indicate that the error is generated by the core.
            stream.abort(ec.value(), ec.message());
        } catch (const std::exception&) {
            // Eat.
        }

        finalize();
    }
}

void
client_rpc_dispatch_t::finalize() {
    std::lock_guard<std::mutex> lock(mutex);

    switch (state) {
    case state_t::open:
        state = state_t::closed;
        break;
    case state_t::bound:
        state = state_t::closed;
        callback(ec);
        break;
    case state_t::closed:
        break;
    default:
        BOOST_ASSERT(false);
    }
}
